#!/usr/bin/python3
import glob
import io
import os
import requests
import subprocess
import sys
import zipfile

LANG_MAP = {
	"cpp": '#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\t\n\treturn 0;\n}\n',
	"python": 'import sys\n\n'
}

LANG_EXT = {
	"cpp": ".cpp",
	"python": ".py"
}

EXEC_MAP = {
	"cpp": ["{0}/a.out"],
	"py": ["python3", "{0}/{1}"]
}

URL = "https://open.kattis.com/problems/"

def usage(id = 0):
	if id == 0:
		print("Usage: kattis <command> [arguments] [options]\n")
		print("Commands:")
		for command in sorted(commands.keys()):
			print("\t{}\t{}".format(command, commands[command].__doc__))
	elif id == 1:
		print("Usage: kattis init <problem id> <language(cpp, python)> [options]\n")
		print("Languages:")
		for lang in sorted(LANG_MAP.keys()):
			print("\t" + lang)
	elif id == 2:
		print("Usage: kattis test <problem id> [sample id]")


def init(args):
	"""Download a problem and sample data from Kattis"""

	if len(args) < 2:
		usage(1)
		return 1

	problem, lang = args[0].lower(), args[1].lower()
	sampleData = True

	if lang not in LANG_MAP:
		print("'" + lang + "' is not a valid language. Available languages: "
	          + ", ".join(list(LANG_MAP.keys())))
		return 1

	try:
		r = requests.get(URL + problem + "/file/statement/samples.zip", stream=True)
		z = zipfile.ZipFile(io.BytesIO(r.content))
	except:
		if requests.get(URL + problem).status_code == 200:
			sampleData = False
		else:
			print("Unable to find problem \"" + problem + '"')
			return 1

	if not os.path.exists("problems/" + problem):
		os.mkdir("problems/" + problem)

	if not os.path.exists("problems/" + problem + "/samples"):
		os.mkdir("problems/" + problem + "/samples")

	if sampleData:
		samplePath = "problems/" + problem + "/samples/"
		z.extractall(samplePath)
		files = sorted(os.listdir(samplePath))
		for i in range(0, len(files)//2):
			for j in range(2):
				name, ext = files[2*i+j].split('.')
				os.rename(
					"{}{}.{}".format(samplePath, name, ext),
					"{}{}.{}".format(samplePath, i+1, ext)
				)

	f = open("problems/" + problem + "/" + problem + LANG_EXT[lang], "w")
	f.write(LANG_MAP[lang])
	f.close()


def test(args):
	"""Test your program against all of the sample data (won't work with variable answers)"""
	if len(args) < 1:
		usage(2)
		return 1

	problem = args[0].lower()

	if not os.path.exists("./problems/" + problem):
		print("Problem '{}' does not exist".format(problem))
		return 1

	search = args[1] if len(args) >= 2 and args[1] != "-v" else '*'
	inSamples = glob.glob("./problems/" + problem + "/samples/{}.in".format(search))
	outSamples = glob.glob("./problems/" + problem + "/samples/{}.ans".format(search))
	verbose = len(args) >= 2 and args[-1] == "-v"

	if len(inSamples) == 0:
		if search == '*':
			print("No sample files found")
		else:
			print("No sample file '" + search + "'")
		return 1

	try:
		script = glob.glob("./problems/" + problem + "/" + problem + ".*")[0]
		ext = script.split('.')[-1]
		if ext not in EXEC_MAP:
			raise Exception("No source code found")
	except:
		print("Error: No source code found!")
		return 1
	path = os.path.dirname(script)
	source = os.path.basename(script)
	results = [False]*len(inSamples)
	for i in range(len(inSamples)):
		cmd = [part.format(path, script) for part in EXEC_MAP[ext]]
		try:
			p = subprocess.Popen(cmd, stdin=subprocess.PIPE,
			                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
			with open(inSamples[i], 'rb') as f:
				stdout, stderr = p.communicate(f.read(), 5)
		except subprocess.TimeoutExpired:
			print("Took too long!")
			continue
		except subprocess.SubprocessError:
			print("Runtime error")
			continue
		print("Test #{}:\n".format(i+1))
		linesA = list(filter(None, stdout.decode().split('\n')))
		with open(outSamples[i]) as f:
			linesB = f.readlines()
		result = True
		if len(linesA) == len(linesB):
			for j in range(len(linesA)):
				if verbose:
					print("    ", linesA[j].strip())
				if linesA[j].strip() != linesB[j].strip():
					print("\nResult: Wrong answer\n\n")
					result = False
					break
			results[i] = result
			if result:
				print("\nResult: Accepted\n\n")
				continue
		print("\nResult: Wrong answer\n\n")

	if (results.count(True) == len(results)):
		print("Success!", end="")
	else:
		print("Failed!", end="")
	print(" {}/{} tests passed".format(results.count(True), len(results)))


commands = {
	'init': init,
	'test': test
}

def main(argv):

	if len(argv) < 2 or argv[1] not in commands:
		usage()
		return 1
	else:
		return commands[argv[1]](argv[2:])


if __name__ == '__main__':
	sys.exit(main(sys.argv))
